<?php

/**
 *  Комбинаторика. Алгоритм перебора комбинаций в двоичном формате.
 *
 *  Теоретическое обоснование
 * 1. Наиболее эффективный способ вычисления возможных комбинаций K элементов в M ячейках -
 *    побитовые операции "деления" и "умножения" на 2
 * 1.1 Задача: определить возможные смещения, доступные для 18 фишек в 36 ячейках
 * 1.2. !!!ВНИМАНИЕ!!!  ЗАДАЧА РЕШЕНА С УЧЕТОМ ТОГО, ЧТО ВСЕ ФИШКИ В ЯЧЕЙКАХ "ОДИНАКОВЫЕ", ТОЕСТЬ ПОЛУЧЕННЫЕ ПОЗИЦИИ
 *      ДЛЯ ОДНОЙ ФИШКИ АВТОМАТИЧЕСКИ ПРЕДПОЛАГАЮТ ПРОХОД АНАЛОГИЧНОЙ ОПЕРАЦИИ ДЛЯ КАЖДОЙ ИЗ 18 ФИШЕК. ВО ИЗБЕЖАНИИ ДУБЛИРОВАНИЯ И
 *      УПРОЩЕНИЯ ВЫЧИСЛЕНИЙ ПО ВРЕМЕНИ, ЭТО ВЫЧИСЛЕНИЕ ОПУЩЕНО.
 * 1.3. Количество реальных проходов для каждой фишки равно:
 *
 *      36×35×34×33×32×31×30×29×28×27×26×25×24×23×22×21×20×19 ~= 5,810240762×10²⁵
 *
 * 2.   Для решения задачи разобъем операции на методы нахожджения начала "смещения" - "деление на 2", добавление младших нулей:
 * 2.1. От младшей единицы к более старшей: _byteShiftRight($a)
 * 2.2. Дописывание единицы младшим, в силу смещения вправо: _addOneByteAfterLastOne
 * 2.3. Генерация комбинации. Смещение K фишек на M ячеек от младших к старшим: _findFirstOffsetByte($K, $M)
 * 2.4. Вычислим следующую комбинацию смещения: _findNextOffset($a)
 * 2.5. Будем повторять процесс до нулевого бита смещения
 *
 *	   If K = 2, see self::mergeToAssoc()
 *
 * 3. Каждая операция смещения будет фиксироваться в файлее даных по 100 строк
 * 3.1. В процессе вычислений не допустим выедания памяти выше, установленных по-умолчанию, пороговых значений,
 *    путем перенаправления запросов на другой php-сокет
 *
 * PS. Для более оптимального алгоритма - последовательного расходования памяти, подсчет происходит путем инкремента
 * Число вариантов выводится в интерфейс браузера
 * Если есть необходимость дописать значение именно в первый файл - сообщите, сделаю!!!
 *
 * @link     http://github.com/Correcter/php-chipsincells/
 * @author   Correcter
 * @version  1.0.0
 */

class ChipsInCells
{
    /*
    * @type  const
    * Buffer file name
    */
    const BUFFER_FILE_PATH = './data/possibilities_';

    /*
    * @type  const
    * MEMORY_LIMIT // 20M
    */
    const WORKER_MEMORY_LIMIT = 20;

    /*
     * @type  property
     * Available buffer size with line breaks on each line // 37 BYTES
     * Calc: M + 1 (line break)
     */
    private static  $bytesByString = 0;

    /*
     * @type  property
     * Count of strings should be flushed in each file
     * Определим лимит сброса буфера в файл
     */
    private static  $flushBufferCases = 10000; // LENES!

    // Disable inheritance
    private function _construct(){}

    #@Действие@ : сдвиг вправо младшей единицы, с неприкосновенностью более старших разрядов.
    // Все биты, полученные от исключающего $a -1 сдвинем вправа на 2 позиций. Каждая позиция  - "деление на 2"
    // Установим биты, которые мы получили в результате "деления на 2" или a - 1 позиция.
    private static function _byteShiftRight($a)
    {
        return (($a - 1) ^ (($a ^ ($a - 1)) >> 2));
    }

    #@Действие@ : дописываем единицу справа от самой младшей единицы.
    private static function _addOneByteAfterLastOne($a)
    {
        return ($a | ((($a ^ ($a - 1)) + 1) >> 2));
    }

    #@Действие@ : генерация первой комбинации. K фишек сдвигаются вправо на (M-K) ячеек.
    private static function _findFirstOffsetByte($K, $M)
    {
        return (((1 << $K) - 1) << ($M - $K));
    }

    #@Действие@ : Вычислим следующую комбинацию, определив сначала младший разряд слева
    // и, в зависимости от этого, решим добавлять ли единицу справа от него или просто "делим на 2"
    private static function _findNextOffset($a)
    {
        // в случае последней комбинации вернём ноль и прервем поиск смещений
        if (($a & ($a + 1)) == 0) return 0;
        //($a & 1) -- здесь определим значение младшего разряда
        if ($a & 1) return self::_addOneByteAfterLastOne(self::_findNextOffset($a >> 1) << 1);
        return self::_byteShiftRight($a);
    }


    #@Действие@ : Вычислим память, затраченную на выполнения каждой каждой итерации
    # В случае превышения установленных лимитов, отдадим запрос форку и отделим от основного, чтобы скрипт завершился
    # уже в фоновом режиме
    # Предварительно сохранив результаты выполнения скрипта
    # @return void

    private static function _memoryFullOver($peak = false) {

        if(ceil(memory_get_usage()/1048576) >= self::WORKER_MEMORY_LIMIT) { // In MB
            return true;
        }
        return false;
    }

    /*
     * @ Действие @: сброс в файл всех возможных операций размещения (18 фишек в 36 ячейках)
     *
     * Дополнительные методы для особых случаев размещения:
     * Для возврата матрицы в виде двумерного массива, можно вызвать self::mergeToAssoc()
     *
     * Пример: размещения 4-х фишек в 5 ячейках
     *
     * 11110
     * 11101
     * 11011
     * 10111
     * 01111
     *
     * @param   int $K
     * @param   int $M
     * @return  int
     */
    public static function binaryOffset($K, $M)
    {
        $i = 0;
        $iter = 0;
        $counCases = 0;;
        $localFileIndex = 0;
        $localCases = self::$flushBufferCases; // Облегчим жизнь скрипту

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // ЗДЕСЬ Я УВЕЛИЧУ ВРЕМЯ ИСПОЛНЕНИЯ СКРИПТА, ПОТОМУ ЧТО НЕ КОНСОЛЬ. ВСЕ ОСТАЛЬНОЕ - ПО УМОЛЧАНИЮ   !!
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        set_time_limit(0);

        // Создадим каталог, если его нет
        if(!is_dir('./data')) {
            mkdir('./data', 0777, true);
        }

        // Определим количество байт на строку
        self::$bytesByString = ($M + 1);

        $i = self::_findFirstOffsetByte($K, $M);

        // Откроем буферизацию, с возможностью очистки буфера, каждые $flushBufferCases строк
        ob_start(null,0, PHP_OUTPUT_HANDLER_CLEANABLE);

        do {
            ++$iter;
            ++$counCases;   // Посчитал меньшим злом

            if(self::_memoryFullOver()) {
                // Пока бросаем ексепшн, чтобы не падал fpm-воркер
                throw new Exception(
                    "Сожалеем, использование хеш-таблиц невозможно для этого скрипта. \n 
                     Используйте только поточный вывод или буферизацию!");
                exit(0);
                // Потоки делать не стал - работает и так, но на больших смещениях есть проблемы
                // Если нужно, то адаптирую под консоль и добавлю очереди
                //self::_saveWorker();
            }

            // Каждые self::$flushBufferCases итераций будем писать в открытый заранее файл и
            // сливать туда по self::$flushBufferCases смещений

            echo str_pad(decbin($i), $M, "0", STR_PAD_LEFT) . "\n";

            // Если мы достигли значений сброса буфера
            if($localCases === $iter) {

                // Увеличим индекс файла для буфера
                ++$localFileIndex;

                // Запишем в файл
                self::bufferData($localFileIndex);
                $iter = 0;
            }
        }
        while ($i = self::_findNextOffset($i));

        // Контрольный вызов, если в буфере остались данные
        self::bufferData();

        // Вернем общее кол-во смещений
        // Число огромное, но локальный прекремент показался меньшим злом
        return $counCases;
    }

    /**
     * Сброс буфера в файл, проверяя количество буферизованных (STRINGS_IN_BUFFER)
     * @return  void сохранение буферизованной строки в файл
     */
    private static function bufferData($findex = 0)
    {
        // Получим порог сброса битов в локальную переменную
        $bytes = (self::$flushBufferCases * self::$bytesByString);

        if(ob_get_length() >= $bytes) {

            // Избавимся от повторений конкатенации
            $fname = self::BUFFER_FILE_PATH . $findex;

            $bufFile = fopen($fname, 'w');
            chmod($fname, 0777);
            fwrite($bufFile, ob_get_contents());
            fclose($bufFile);

        } else {
            // Избавимся от повторений конкатенации
            $fname = self::BUFFER_FILE_PATH . 'lastfile';

            $bufFile = fopen($fname, 'w');
            chmod($fname, 0777);

            // Если буфер содержит менее self::$bytesByString * 10 байт
            // Не будем их писать в файл варианты
            if(ob_get_length() <= (self::$bytesByString * 10)) {
                fwrite($bufFile, "Менее 10 вариантов");
            } else {
            // Запишем остатки  перестановок
                fwrite($bufFile, ob_get_contents());
            }

            fclose($bufFile);
        }

        // Очистим буфер для следующей последовательности смещений, если они будут
        ob_clean();
        //ob_end_clean();
    }


    /**
     * Если размещаемых элементов не более 2-х, то можно вернуть 
     * ассоциативный массив последовательного смещения
     * с уникальными перестановками в виде двуммерного массива
     * Для M ячеек, число комбинаций будет (M - 1) * Н / 2.
     *
     * @param   array $items Индексированный массив
     * @return  array        Двумерный индексированный массив
     */
    private static function mergeToAssoc(array $items)
    {
        $a = [];
        for ($i = 0, $M = count($items); $i < $M; $i++)
            for ($j = $i + 1; $j < $M; $j++)
                $a[] = [$items[$j], $items[$i]];
        return $a;
    }

    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
    //!    ЕСЛИ ВДРУГ, НЕКИЙ БЕЗУМЕЦ, ЗАХОЧЕТ ИСПОЛЬЗОВАТЬ ХЕШ-ТАБЛИЦЫ ПХП, КАК ХРАНИЛИЩЕ
    //!                                     РЕЗУЛЬТАТА РАБОТЫ СКРИПТА
    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

    #@Действие@ : Сохранение прогресса ДО падения скрипта: это не спасет от остановки выполнения в данный момент
    # вычислений сдвига куда - либо (ставим в очередь)
    # @return void

    //private static function _saveWorker($worker = 0) {
    // Пишем коннект к RabbitMQ, например, и ставим в очередь наш текущий воркер
    // Или перезапускаем уже с форками в консоли
    //}

    #@Действие@ : Получим незавершенный процесс обработчика ПХП
    # @return php-Instance

    //private static function _getWorker($worker = 0) {
    // Заберем сообщение из очереди и продолжим выполнение скрипта с этого же места
    //}

    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
    //!                                             КОНЕЦ
    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

}

// Начнем вызов, если
if(isset($_REQUEST['K']) && isset($_REQUEST['M']) &&
   (int) $_REQUEST['K'] !== 0 && (int) $_REQUEST['M'] !== 0) {

    // Число огромное, но инкремент показался меньшим злом
    $count = ChipsInCells::binaryOffset($_REQUEST['K'], $_REQUEST['M']);

    echo json_encode([
        'message' => sprintf('Количество возможных смещений: %1$s !', $count),
        'status' => 200
    ]);
    exit;

} else {

    print_r($_REQUEST);
    exit;

    echo json_encode([
        'message' => 'Укажите переменные, для вычисления смещений!',
        'status' => 301
    ]);
    exit;
}

